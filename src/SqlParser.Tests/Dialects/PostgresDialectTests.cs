using System.Data;
using SqlParser.Ast;
using SqlParser.Dialects;
using static SqlParser.Ast.Expression;
using DataType = SqlParser.Ast.DataType;
using ObjectType = SqlParser.Ast.ObjectType;

// ReSharper disable StringLiteralTypo

namespace SqlParser.Tests.Dialects
{
    public class PostgresDialectTests : ParserTestBase
    {
        public PostgresDialectTests()
        {
            DefaultDialects = new[] { new PostgreSqlDialect() };
        }

        [Fact]
        public void Parse_Create_Table_Generated_Always_As_Identity()
        {
            //With primary key
            var sql = """
                CREATE TABLE table2 (
                column21 bigint primary key generated always as identity,
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column21 BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column21 bigint primary key generated by default as identity,
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column21 BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
                 column30 TEXT)
                """);

            //With out primary key
            sql = """
                CREATE TABLE table2 (
                column22 bigint generated always as identity    ,
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column22 bigint generated by default as identity    ,
                 column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED BY DEFAULT AS IDENTITY,
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column23 bigint generated by default as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column23 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column24 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column24 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE ),
                 column30 TEXT)
                """);

            sql = """
                CREATE TABLE table2 (
                column25 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column25 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 ),
                 column30 TEXT)
                """);

            sql = """
                CREATE TABLE table2 (
                column26 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column26 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column27 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column27 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column28 bigint generated by default as identity (INCREMENT 1 MINVALUE 1 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column28 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column29 bigint generated by default as identity (INCREMENT 1 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column29 BIGINT GENERATED BY DEFAULT AS IDENTITY (
                 INCREMENT 1 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column22 bigint generated always as identity    ,
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column22 BIGINT GENERATED ALWAYS AS IDENTITY,
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column23 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column23 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column24 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column24 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 CYCLE ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column25 bigint generated always as identity (INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column25 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column26 bigint generated always as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column26 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column27 bigint generated always as identity (
                INCREMENT 1 MINVALUE 1 MAXVALUE 20),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column27 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 MAXVALUE 20 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column28 bigint generated always as identity (INCREMENT 1 MINVALUE 1 ),
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column28 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 MINVALUE 1 ),
                 column30 TEXT)
                """);


            sql = """
                CREATE TABLE table2 (
                column29 bigint generated always as identity (
                 INCREMENT 1 ),
                 column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                column29 BIGINT GENERATED ALWAYS AS IDENTITY (
                 INCREMENT 1 ),
                 column30 TEXT)
                """);

            sql = """
                CREATE TABLE table2 (
                priceInDollar numeric,
                princeInPound numeric GENERATED ALWAYS AS(priceInDollar* 0.22) STORED,
                column30 text );
                """;
            OneStatementParsesTo(sql,
                """
                CREATE TABLE table2 (
                priceInDollar NUMERIC,
                 princeInPound NUMERIC GENERATED ALWAYS AS (priceInDollar * 0.22) STORED,
                 column30 TEXT)
                """
            );
        }

        [Fact]
        public void Parse_Create_Sequence()
        {
            var sql = "CREATE SEQUENCE  name0";
            OneStatementParsesTo(sql, "CREATE SEQUENCE name0");


            sql = "CREATE SEQUENCE  IF NOT EXISTS  name0";
            OneStatementParsesTo(sql, "CREATE SEQUENCE IF NOT EXISTS name0");


            sql = "CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name0";
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name0");


            sql = "CREATE TEMPORARY SEQUENCE  name0";
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE name0");


            sql = """
                CREATE TEMPORARY SEQUENCE IF NOT EXISTS  name1
                AS BIGINT
                INCREMENT BY  1
                MINVALUE 1  MAXVALUE 20
                START WITH 10
                """;
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name1 AS BIGINT INCREMENT BY 1 MINVALUE 1 MAXVALUE 20 START WITH 10");


            sql = """ 
                CREATE SEQUENCE IF NOT EXISTS  name2
                AS BIGINT
                INCREMENT  1
                MINVALUE 1  MAXVALUE 20
                START WITH 10 CACHE 2 NO CYCLE
                """;
            OneStatementParsesTo(sql, "CREATE SEQUENCE IF NOT EXISTS name2 AS BIGINT INCREMENT 1 MINVALUE 1 MAXVALUE 20 START WITH 10 CACHE 2 NO CYCLE");


            sql = """
                CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
                INCREMENT  1
                NO MINVALUE  MAXVALUE 20 CACHE 2 CYCLE
                """;
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 CACHE 2 CYCLE");


            sql = """
                CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
                INCREMENT  1
                NO MINVALUE  MAXVALUE 20 OWNED BY public.table01
                """;
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 OWNED BY public.table01");


            sql = """
            CREATE TEMPORARY SEQUENCE  IF NOT EXISTS  name3
            INCREMENT  1
            NO MINVALUE  MAXVALUE 20 OWNED BY NONE
            """;
            OneStatementParsesTo(sql, "CREATE TEMPORARY SEQUENCE IF NOT EXISTS name3 INCREMENT 1 NO MINVALUE MAXVALUE 20 OWNED BY NONE");
        }

        [Fact]
        public void Parse_Drop_Sequence()
        {
            var sql = "DROP SEQUENCE IF EXISTS  name0 CASCADE";
            OneStatementParsesTo(sql, "DROP SEQUENCE IF EXISTS name0 CASCADE");


            sql = "DROP SEQUENCE IF EXISTS  name1 RESTRICT";
            OneStatementParsesTo(sql, "DROP SEQUENCE IF EXISTS name1 RESTRICT");


            sql = "DROP SEQUENCE  name2 CASCADE";
            OneStatementParsesTo(sql, "DROP SEQUENCE name2 CASCADE");


            sql = "DROP SEQUENCE  name2";
            OneStatementParsesTo(sql, "DROP SEQUENCE name2");


            sql = "DROP SEQUENCE  name0 CASCADE";
            OneStatementParsesTo(sql, "DROP SEQUENCE name0 CASCADE");


            sql = "DROP SEQUENCE  name1 RESTRICT";
            OneStatementParsesTo(sql, "DROP SEQUENCE name1 RESTRICT");


            sql = "DROP SEQUENCE  name1, name2, name3";
            OneStatementParsesTo(sql, "DROP SEQUENCE name1, name2, name3");
        }

        [Fact]
        public void Parse_Create_Table_With_Defaults()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var sql = """
                CREATE TABLE public.customer (
                customer_id integer DEFAULT nextval(public.customer_customer_id_seq),
                store_id smallint NOT NULL,
                first_name character varying(45) NOT NULL,
                last_name character varying(45) COLLATE "es_ES" NOT NULL,
                email character varying(50),
                address_id smallint NOT NULL,
                activebool boolean DEFAULT true NOT NULL,
                create_date date DEFAULT now()::text NOT NULL,
                last_update timestamp without time zone DEFAULT now() NOT NULL,
                active int NOT NULL
                ) WITH (fillfactor = 20, user_catalog_table = true, autovacuum_vacuum_threshold = 100)
                """;

            var create = OneStatementParsesTo<Statement.CreateTable>(sql, "");

            var expected = new ColumnDef[]
            {
                new("customer_id", new DataType.Integer(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.Default(VerifiedExpr("nextval(public.customer_customer_id_seq)")))
                }),

                new("store_id", new DataType.SmallInt(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.NotNull())
                }),

                new("first_name", new DataType.CharacterVarying(new CharacterLength(45)),
                    Options: new ColumnOptionDef[]
                    {
                        new(new ColumnOption.NotNull())
                    }),

                new("last_name", new DataType.CharacterVarying(new CharacterLength(45)),
                    new ObjectName(new Ident("es_ES", Symbols.DoubleQuote)),
                    new ColumnOptionDef[]
                    {
                        new(new ColumnOption.NotNull())
                    }
                ),

                new("email", new DataType.CharacterVarying(new CharacterLength(50))),

                new("address_id", new DataType.SmallInt(), Options: new ColumnOptionDef[]
                {
                   new(new ColumnOption.NotNull())
                }),

                new("activebool", new DataType.Boolean(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.Default(new LiteralValue(new Value.Boolean(true)))),
                    new(new ColumnOption.NotNull())
                }),

                new("create_date", new DataType.Date(), Options: new ColumnOptionDef[] 
                {
                    new(new ColumnOption.Default(VerifiedExpr("CAST(now() AS TEXT)"))),
                    new(new ColumnOption.NotNull())
                }),

                new("last_update", new DataType.Timestamp(TimezoneInfo.WithoutTimeZone),
                    Options: new ColumnOptionDef[]
                    {
                        new(new ColumnOption.Default(VerifiedExpr("now()"))),
                        new(new ColumnOption.NotNull())
                    }),

                new("active", new DataType.Int(), Options: new ColumnOptionDef[]
                {
                    new(new ColumnOption.NotNull())
                })
            };

            Assert.Equal("public.customer", create.Name);
            Assert.Equal(expected, create.Columns);
        }

        [Fact]
        public void Parse_Create_Table_From_Pg_Dump()
        {
            const string sql = """
                CREATE TABLE public.customer (
                customer_id integer DEFAULT nextval('public.customer_customer_id_seq'::regclass) NOT NULL,
                store_id smallint NOT NULL,
                first_name character varying(45) NOT NULL,
                last_name character varying(45) NOT NULL,
                info text[],
                address_id smallint NOT NULL,
                activebool boolean DEFAULT true NOT NULL,
                create_date date DEFAULT now()::DATE NOT NULL,
                create_date1 date DEFAULT 'now'::TEXT::date NOT NULL,
                last_update timestamp without time zone DEFAULT now(),
                release_year public.year,
                active int
                )
                """;
            var canonical = """
                CREATE TABLE public.customer (
                customer_id INTEGER DEFAULT nextval(CAST('public.customer_customer_id_seq' AS REGCLASS)) NOT NULL,
                 store_id SMALLINT NOT NULL,
                 first_name CHARACTER VARYING(45) NOT NULL,
                 last_name CHARACTER VARYING(45) NOT NULL,
                 info TEXT[],
                 address_id SMALLINT NOT NULL,
                 activebool BOOLEAN DEFAULT true NOT NULL,
                 create_date DATE DEFAULT CAST(now() AS DATE) NOT NULL,
                 create_date1 DATE DEFAULT CAST(CAST('now' AS TEXT) AS DATE) NOT NULL,
                 last_update TIMESTAMP WITHOUT TIME ZONE DEFAULT now(),
                 release_year public.year,
                 active INT
                )
                """;
            OneStatementParsesTo(sql, canonical);
        }

        [Fact]
        public void Parse_Create_Table_With_Inherit()
        {
            const string sql = """
                CREATE TABLE bazaar.settings (
                settings_id UUID PRIMARY KEY DEFAULT uuid_generate_v4() NOT NULL, 
                user_id UUID UNIQUE, 
                value TEXT[], 
                use_metric BOOLEAN DEFAULT true
                )
                """;

            VerifiedStatement(sql);
        }

        [Fact]
        public void Parse_Create_Table_Empty()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            // Zero-column tables are weird, but supported by at least PostgreSQL.
            // <https://github.com/sqlparser-rs/sqlparser-rs/pull/94>
            VerifiedStatement("CREATE TABLE t ()");
        }

        [Fact]
        public void Parse_Create_Table_Constraints_Only()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var create = VerifiedStatement<Statement.CreateTable>("CREATE TABLE t (CONSTRAINT positive CHECK (2 > 1))");

            var expected = new TableConstraint.Check(new BinaryOp(
                new LiteralValue(Number("2")),
               BinaryOperator.Gt,
                new LiteralValue(Number("1"))
            ), "positive");
            Assert.Equal("t", create.Name);
            Assert.Equal(expected, create.Constraints!.Single());
        }

        [Fact]
        public void Parse_Alter_Table_Constraints_Rename()
        {
            var alter = VerifiedStatement<Statement.AlterTable>(
                "ALTER TABLE tab RENAME CONSTRAINT old_name TO new_name");
            var op = (AlterTableOperation.RenameConstraint)alter.Operation;

            Assert.Equal("tab", alter.Name);
            Assert.Equal("old_name", op.OldName);
            Assert.Equal("new_name", op.NewName);
        }

        [Fact]
        public void Parse_Alter_Table_Alter_Column()
        {
            OneStatementParsesTo(
                "ALTER TABLE tab ALTER COLUMN is_active TYPE TEXT USING 'text'",
                "ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'");

            var alter = VerifiedStatement<Statement.AlterTable>(
                "ALTER TABLE tab ALTER COLUMN is_active SET DATA TYPE TEXT USING 'text'");
            var op = (AlterTableOperation.AlterColumn)alter.Operation;
            var @using = new LiteralValue(new Value.SingleQuotedString("text"));

            Assert.Equal("tab", alter.Name);
            Assert.Equal("is_active", op.ColumnName);
            Assert.Equal(new AlterColumnOperation.SetDataType(new DataType.Text(), @using), op.Operation);
        }

        [Fact]
        public void Parse_Create_Table_If_Not_Exists()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var create = VerifiedStatement<Statement.CreateTable>("CREATE TABLE IF NOT EXISTS uk_cities ()");

            Assert.Equal("uk_cities", create.Name);
        }

        [Fact]
        public void Parse_Bad_If_Not_Exists()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF EXISTS uk_cities ()"));
            Assert.Equal("Expected end of statement, found EXISTS, Line: 1, Col: 17", ex.Message);

            ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF EXISTS uk_cities ()"));
            Assert.Equal("Expected end of statement, found EXISTS, Line: 1, Col: 17", ex.Message);

            ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF uk_cities ()"));
            Assert.Equal("Expected end of statement, found uk_cities, Line: 1, Col: 17", ex.Message);

            ex = Assert.Throws<ParserException>(() => ParseSqlStatements("CREATE TABLE IF NOT uk_cities ()"));
            Assert.Equal("Expected end of statement, found NOT, Line: 1, Col: 17", ex.Message);
        }

        [Fact]
        public void Parse_Create_Schema_If_Not_Exists()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var create = VerifiedStatement<Statement.CreateSchema>("CREATE SCHEMA IF NOT EXISTS schema_name");
            var name = (SchemaName.Simple)create.Name;
            Assert.Equal("schema_name", name.Name);
        }

        [Fact]
        public void Parse_Drop_Schema_If_Exists()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var drop = VerifiedStatement<Statement.Drop>("DROP SCHEMA IF EXISTS schema_name");
            Assert.Equal(ObjectType.Schema, drop.ObjectType);
        }

        [Fact]
        public void Parse_Copy_From_Stdin()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            const string sql = """
                COPY public.actor (actor_id, first_name, last_name, last_update, value) FROM stdin;
                1	PENELOPE	GUINESS	2006-02-15 09:34:33 0.11111
                2	NICK	WAHLBERG	2006-02-15 09:34:33 0.22222
                3	ED	CHASE	2006-02-15 09:34:33 0.312323
                4	JENNIFER	DAVIS	2006-02-15 09:34:33 0.3232
                5	JOHNNY	LOLLOBRIGIDA	2006-02-15 09:34:33 1.343
                6	BETTE	NICHOLSON	2006-02-15 09:34:33 5.0
                7	GRACE	MOSTEL	2006-02-15 09:34:33 6.0
                8	MATTHEW	JOHANSSON	2006-02-15 09:34:33 7.0
                9	JOE	SWANK	2006-02-15 09:34:33 8.0
                10	CHRISTIAN	GABLE	2006-02-15 09:34:33 9.1
                11	ZERO	CAGE	2006-02-15 09:34:33 10.001
                12	KARL	BERRY	2017-11-02 19:15:42.308637+08 11.001
                A Fateful Reflection of a Waitress And a Boat who must Discover a Sumo Wrestler in Ancient China
                Kwara & Kogi
                {""Deleted Scenes"",""Behind the Scenes""}
                'awe':5 'awe-inspir':4 'barbarella':1 'cat':13 'conquer':16 'dog':18 'feminist':10 'inspir':6 'monasteri':21 'must':15 'stori':7 'streetcar':2
                PHP	₱ USD $
                \N  Some other value
                \\.
                """;

            OneStatementParsesTo(sql, "");
        }

        [Fact]
        public void Test_Copy_To()
        {
            var copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv'");
            var source = new CopySource.Table(new ObjectName("users"), new Sequence<Ident>());
            var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"));
            Assert.Equal(expected, copy);


            copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv' DELIMITER ','");
            expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
            {
                LegacyOptions = new []
                {
                    new CopyLegacyOption.Delimiter(Symbols.Comma)
                }
            };
            Assert.Equal(expected, copy);


            copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv' DELIMITER ',' CSV HEADER");
            expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
            {
                LegacyOptions = new CopyLegacyOption[]
                {
                    new CopyLegacyOption.Delimiter(Symbols.Comma),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[] {new CopyLegacyCsvOption.Header()})
                }
            };
            Assert.Equal(expected, copy);
        }

        [Fact]
        public void Parse_Copy_From()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            const string sql = """
                COPY table (a, b) FROM 'file.csv' WITH
                (
                    FORMAT CSV,
                    FREEZE,
                    FREEZE TRUE,
                    FREEZE FALSE,
                    DELIMITER ',',
                    NULL '',
                    HEADER,
                    HEADER TRUE,
                    HEADER FALSE,
                    QUOTE '"',
                    ESCAPE '\',
                    FORCE_QUOTE (a, b),
                    FORCE_NOT_NULL (a),
                    FORCE_NULL (b),
                    ENCODING 'utf8'
                )
                """;

            var copy = OneStatementParsesTo(sql, "");

            var source = new CopySource.Table(new ObjectName("table"), new Sequence<Ident> {"a", "b"});

            var expected = new Statement.Copy(
                source,
                false,
                new CopyTarget.File("file.csv"))
            {
                Options = new CopyOption[]
                {
                    new CopyOption.Format("CSV"),
                    new CopyOption.Freeze(true),
                    new CopyOption.Freeze(true),
                    new CopyOption.Freeze(false),
                    new CopyOption.Delimiter(','),
                    new CopyOption.Null(""),
                    new CopyOption.Header(true),
                    new CopyOption.Header(true),
                    new CopyOption.Header(false),
                    new CopyOption.Quote('"'),
                    new CopyOption.Escape('\\'),
                    new CopyOption.ForceQuote(new Ident[] {"a", "b"}),
                    new CopyOption.ForceNotNull(new Ident[] {"a"}),
                    new CopyOption.ForceNull(new Ident[] {"b"}),
                    new CopyOption.Encoding("utf8"),
                }
            };

            Assert.Equal(expected, copy);
        }

        [Fact]
        public void Parse_Copy_To()
        {
            var copy = VerifiedStatement<Statement.Copy>("COPY users TO 'data.csv'");
            var source = new CopySource.Table(new ObjectName("users"), new Sequence<Ident>());
            var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"));
            Assert.Equal(expected, copy);


            copy = VerifiedStatement<Statement.Copy>("COPY country TO STDOUT (DELIMITER '|')");
            source = new CopySource.Table(new ObjectName("country"), new Sequence<Ident>());
            expected = new Statement.Copy(source, true, new CopyTarget.Stdout())
            {
                Options = new [] { new CopyOption.Delimiter(Symbols.Pipe) }
            };
            Assert.Equal(expected, copy);


            copy = VerifiedStatement<Statement.Copy>("COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz'");
            expected = new Statement.Copy(source, true, new CopyTarget.Program("gzip > /usr1/proj/bray/sql/country_data.gz"));
            Assert.Equal(expected, copy);
        }

        [Fact]
        public void Parse_Copy_From_Before_v9_0()
        {
            var copy = VerifiedStatement<Statement.Copy>(
                "COPY users FROM 'data.csv' BINARY DELIMITER ',' NULL 'null' CSV HEADER QUOTE '\"' ESCAPE '\\' FORCE NOT NULL column");
            var source = new CopySource.Table(new ObjectName("users"), new Sequence<Ident>());
            var expected = new Statement.Copy(source, false, new CopyTarget.File("data.csv"))
            {
                LegacyOptions = new CopyLegacyOption[]
                {
                    new CopyLegacyOption.Binary(),
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Header(),
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                        new CopyLegacyCsvOption.ForceNotNull(new Ident[] {"column"}),
                    })
                }
            };

            Assert.Equal(expected, copy);


            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            copy = OneStatementParsesTo<Statement.Copy>("COPY users FROM 'data.csv' DELIMITER AS ',' NULL AS 'null' CSV QUOTE AS '\"' ESCAPE AS '\\'", "");

            expected = new Statement.Copy(source, false, new CopyTarget.File("data.csv"))
            {
                LegacyOptions = new CopyLegacyOption[]
                {
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                    }),
                }
            };

            Assert.Equal(expected, copy);
        }

        [Fact]
        public void Parse_Copy_To_Before_v9_0()
        {
            var copy = VerifiedStatement<Statement.Copy>(
                "COPY users TO 'data.csv' BINARY DELIMITER ',' NULL 'null' CSV HEADER QUOTE '\"' ESCAPE '\\' FORCE QUOTE column");
            var source = new CopySource.Table(new ObjectName("users"), new Sequence<Ident>());
            var expected = new Statement.Copy(source, true, new CopyTarget.File("data.csv"))
            {
                LegacyOptions = new CopyLegacyOption[]
                {
                    new CopyLegacyOption.Binary(),
                    new CopyLegacyOption.Delimiter(','),
                    new CopyLegacyOption.Null("null"),
                    new CopyLegacyOption.Csv(new CopyLegacyCsvOption[]
                    {
                        new CopyLegacyCsvOption.Header(),
                        new CopyLegacyCsvOption.Quote('\"'),
                        new CopyLegacyCsvOption.Escape('\\'),
                        new CopyLegacyCsvOption.ForceQuote(new Ident[] {"column"}),
                    })
                }
            };

            Assert.Equal(expected, copy);


            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

        }

        [Fact]
        public void Parse_Set()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var set = VerifiedStatement<Statement.SetVariable>("SET a = b");
            Assert.Equal("a", set.Variable!);
            Assert.Equal(new []{ new Identifier("b") }, set.Value);

            set = VerifiedStatement<Statement.SetVariable>("SET a = 'b'");
            Assert.Equal("a", set.Variable!);
            Assert.Equal(new []{ new LiteralValue(new Value.SingleQuotedString("b")) }, set.Value);

            set = VerifiedStatement<Statement.SetVariable>("SET a = 0");
            Assert.Equal("a", set.Variable!);
            Assert.Equal(new []{ new LiteralValue(Number("0")) }, set.Value);

            set = VerifiedStatement<Statement.SetVariable>("SET a = DEFAULT");
            Assert.Equal("a", set.Variable!);
            Assert.Equal(new []{ new Identifier("DEFAULT") }, set.Value);

            set = VerifiedStatement<Statement.SetVariable>("SET LOCAL a = b");
            Assert.Equal("a", set.Variable!);
            Assert.True(set.Local);
            Assert.Equal(new []{ new Identifier("b") }, set.Value);

            set = VerifiedStatement<Statement.SetVariable>("SET a.b.c = b");
            Assert.Equal(new ObjectName(new Ident[] { "a", "b", "c" }), set.Variable!);
            Assert.Equal(new []{ new Identifier("b") }, set.Value);

            set = OneStatementParsesTo<Statement.SetVariable>(
                "SET hive.tez.auto.reducer.parallelism=false",
                "SET hive.tez.auto.reducer.parallelism = false");

            Assert.Equal(new ObjectName(new Ident[] { "hive", "tez", "auto", "reducer", "parallelism" }), set.Variable!);
            Assert.Equal(new []{ new LiteralValue(new Value.Boolean(false)) }, set.Value);

            OneStatementParsesTo("SET a TO b", "SET a = b");
            OneStatementParsesTo("SET SESSION a = b", "SET a = b");

            var ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET"));
            Assert.Equal("Expected identifier, found EOF", ex.Message);

            ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET a b"));
            Assert.Equal("Expected equal sign or TO, found b, Line: 1, Col: 7", ex.Message);

            ex = Assert.Throws<ParserException>(() => ParseSqlStatements("SET a ="));
            Assert.Equal("Expected variable value, found EOF", ex.Message);
        }

        [Fact]
        public void Parse_Set_Role()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var set = VerifiedStatement<Statement.SetRole>("SET SESSION ROLE NONE");
            Assert.Equal(ContextModifier.Session, set.ContextModifier);

            set = VerifiedStatement<Statement.SetRole>("SET LOCAL ROLE \"rolename\"");
            Assert.Equal(ContextModifier.Local, set.ContextModifier);
            Assert.Equal(new Ident("rolename", Symbols.DoubleQuote), set.Name);

            set = VerifiedStatement<Statement.SetRole>("SET ROLE 'rolename'");
            Assert.Equal(ContextModifier.None, set.ContextModifier);
            Assert.Equal(new Ident("rolename", Symbols.SingleQuote), set.Name);
        }

        [Fact]
        public void Parse_Show()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var show = VerifiedStatement<Statement.ShowVariable>("SHOW a a");
            Assert.Equal(new Statement.ShowVariable(new Ident[]{ "a", "a" }), show);

            show = VerifiedStatement<Statement.ShowVariable>("SHOW ALL ALL");
            Assert.Equal(new Statement.ShowVariable(new Ident[]{ "ALL", "ALL" }), show);
        }

        [Fact]
        public void Parse_Deallocate()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE a");
            Assert.Equal("a", deallocate.Name);
            Assert.False(deallocate.Prepared);

            deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE ALL");
            Assert.Equal("ALL", deallocate.Name);
            Assert.False(deallocate.Prepared);

            deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE PREPARE a");
            Assert.Equal("a", deallocate.Name);
            Assert.True(deallocate.Prepared);

            deallocate = VerifiedStatement<Statement.Deallocate>("DEALLOCATE PREPARE ALL");
            Assert.Equal("ALL", deallocate.Name);
            Assert.True(deallocate.Prepared);
        }

        [Fact]
        public void Parse_Execute()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var execute = VerifiedStatement<Statement.Execute>("EXECUTE a");
            Assert.Equal(new Statement.Execute("a"), execute);

            execute = VerifiedStatement<Statement.Execute>("EXECUTE a(1, 't')");
            var parameters = new[]
            {
                new LiteralValue(Number("1")),
                new LiteralValue(new Value.SingleQuotedString("t"))
            };
            Assert.Equal(new Statement.Execute("a", parameters), execute);
        }

        [Fact]
        public void Parse_Prepare()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var prepare = VerifiedStatement<Statement.Prepare>("PREPARE a AS INSERT INTO customers VALUES (a1, a2, a3)");
            var insert = (Statement.Insert)prepare.Statement;
            var source = (Query)insert.Source;
            var values = (SetExpression.ValuesExpression)source.Body;
            Assert.Equal("a", prepare.Name);

            var expected = new []
            {
                new Identifier("a1"),
                new Identifier("a2"),
                new Identifier("a3")
            };

            Assert.Equal(expected, values.Values.Rows.First());
        }

        [Fact]
        public void Parse_Pg_On_Conflict()
        {
            var insert = VerifiedStatement<Statement.Insert>("""
                INSERT INTO distributors (did, dname)
                 VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
                 ON CONFLICT(did)
                 DO UPDATE SET dname = EXCLUDED.dname
                """);

            var on = new OnInsert.Conflict(new OnConflict(new OnConflictAction.DoUpdate(new DoUpdateAction(
                new Statement.Assignment[]
                {
                    new(new Ident[]{"dname"}, new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED", "dname"
                    }))
                }
            )))
            {
                ConflictTarget = new ConflictTarget.Column(new Ident[]{ "did" })
            });

            Assert.Equal(on, insert.On);


            insert = VerifiedStatement<Statement.Insert>("""
                INSERT INTO distributors (did, dname, area)
                 VALUES (5, 'Gizmo Transglobal', 'Mars'), (6, 'Associated Computing, Inc', 'Venus')
                 ON CONFLICT(did, area)
                 DO UPDATE SET dname = EXCLUDED.dname, area = EXCLUDED.area
                """);

            on = new OnInsert.Conflict(new OnConflict(new OnConflictAction.DoUpdate(new DoUpdateAction(
                new Statement.Assignment[]
                {
                    new(new Ident[]{"dname"}, new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED",
                        "dname"
                    })),

                    new(new Ident[]{"area"}, new CompoundIdentifier(new Ident[]
                    {
                        "EXCLUDED",
                        "area"
                    }))
                })))
            {
                ConflictTarget = new ConflictTarget.Column(new Ident[]
                {
                    "did",
                    "area"
                })
            });

            Assert.Equal(on, insert.On);
        }

        [Fact]
        public void Parse_Pg_Returning()
        {
            var sql = "INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets') RETURNING did";
            var insert = VerifiedStatement<Statement.Insert>(sql);

            Assert.Equal("did", ((Identifier)((SelectItem.UnnamedExpression)insert.Returning![0]).Expression).Ident);

            sql = """
                UPDATE weather SET temp_lo = temp_lo + 1, temp_hi = temp_lo + 15, prcp = DEFAULT
                 WHERE city = 'San Francisco' AND date = '2003-07-03'
                 RETURNING temp_lo AS lo, temp_hi AS hi, prcp
                """;

            var update = VerifiedStatement<Statement.Update>(sql);

            var expected = new SelectItem[]
            {
                new SelectItem.ExpressionWithAlias(new Identifier("temp_lo"), "lo"),
                new SelectItem.ExpressionWithAlias(new Identifier("temp_hi"), "hi"),
                new SelectItem.UnnamedExpression(new Identifier("prcp"))
            };

            Assert.Equal(expected, update.Returning!);

            sql = "DELETE FROM tasks WHERE status = 'DONE' RETURNING *";
            var delete = VerifiedStatement<Statement.Delete>(sql);

            expected = new SelectItem[]
            {
                new SelectItem.Wildcard(new WildcardAdditionalOptions()),
            };
            Assert.Equal(expected, delete.Returning!);
        }

        [Fact]
        public void Parse_Pg_Binary_Ops()
        {
            var ops = new (string Text, BinaryOperator Operator, IEnumerable<Dialect> Dialects)[]
            {
                // Sharp char and Caret cannot be used with Generic Dialect, it conflicts with identifiers
                //("#", BinaryOperator.PGBitwiseXor, new Dialect[] {new PostgreSqlDialect()}),
                //("^", BinaryOperator.PGExp, new Dialect[] {new PostgreSqlDialect()}),
                //(">>", BinaryOperator.PGBitwiseShiftRight, new Dialect[] {new PostgreSqlDialect(), new GenericDialect()}),
                //("<<", BinaryOperator.PGBitwiseShiftLeft, new Dialect[] {new PostgreSqlDialect(), new GenericDialect()}),
                ("&&", BinaryOperator.PGOverlap, new Dialect[] {new PostgreSqlDialect()}),
            };

            foreach (var op in ops)
            {
                var select = VerifiedOnlySelect($"SELECT a {op.Text} b", op.Dialects);
                Assert.Equal(new SelectItem.UnnamedExpression(new BinaryOp(
                    new Identifier("a"),
                    op.Operator,
                    new Identifier("b")
                )), select.Projection[0]);
            }
        }

        [Fact]
        public void Parse_Pg_Unary_Ops()
        {
            var ops = new (string Text, UnaryOperator Operator)[]
            {
                ("~", UnaryOperator.PGBitwiseNot),
                ("|/", UnaryOperator.PGSquareRoot),
                ("||/", UnaryOperator.PGCubeRoot),
                ("!!", UnaryOperator.PGPrefixFactorial),
                ("@", UnaryOperator.PGAbs)
            };

            foreach (var op in ops)
            {
                var select = VerifiedOnlySelect($"SELECT {op.Text}a");
                Assert.Equal(new SelectItem.UnnamedExpression(new UnaryOp(new Identifier("a"), op.Operator)),
                    select.Projection[0]);
            }
        }

        [Fact]
        public void Parse_Pg_Postfix_Factorial()
        {
            var select = VerifiedOnlySelect("SELECT a!");

            Assert.Equal(new SelectItem.UnnamedExpression(new UnaryOp(new Identifier("a"), UnaryOperator.PGPostfixFactorial)),
                select.Projection[0]);
        }

        [Fact]
        public void Parse_Pg_Regex_Match_Ops()
        {
            var ops = new (string Text, BinaryOperator Op)[]
            {
                new("~", BinaryOperator.PGRegexMatch),
                new("~*", BinaryOperator.PGRegexIMatch),
                new("!~", BinaryOperator.PGRegexNotMatch),
                new("!~*", BinaryOperator.PGRegexNotIMatch),
            };

            foreach (var op in ops)
            {
                var select = VerifiedOnlySelect($"SELECT 'abc' {op.Text} '^a'");
                Assert.Equal(new SelectItem.UnnamedExpression(new BinaryOp(
                    new LiteralValue(new Value.SingleQuotedString("abc")),
                    op.Op,
                    new LiteralValue(new Value.SingleQuotedString("^a"))
                )), select.Projection[0]);
            }
        }

        [Fact]
        public void Parse_Array_Index_Expr()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var num = Enumerable.Range(0, 11).Select(i => new LiteralValue(Number(i.ToString()))).ToList();

            var sql = "SELECT foo[0] FROM foos";
            var select = VerifiedOnlySelect(sql);
            var expected = new ArrayIndex(new Identifier("foo"), new[]
            {
                num[0]
            });
            Assert.Equal(expected, select.Projection.Single().AsExpr());


            sql = "SELECT foo[0][0] FROM foos";
            select = VerifiedOnlySelect(sql);
            expected = new ArrayIndex(new Identifier("foo"), new Expression[]
            {
                num[0],
                num[0]
            });
            Assert.Equal(expected, select.Projection.Single().AsExpr());


            sql = "SELECT bar[0][\"baz\"][\"fooz\"] FROM foos";
            select = VerifiedOnlySelect(sql);
            expected = new ArrayIndex(new Identifier("bar"), new Expression[]
            {
                num[0],
                new Identifier(new Ident("baz", Symbols.DoubleQuote)),
                new Identifier(new Ident("fooz", Symbols.DoubleQuote))
            });
            Assert.Equal(expected, select.Projection.Single().AsExpr());


            sql = "SELECT (CAST(ARRAY[ARRAY[2, 3]] AS INT[][]))[1][2]";
            select = VerifiedOnlySelect(sql);

            expected = new ArrayIndex(new Nested(
                    new Cast(
                        new Expression.Array(
                            new ArrayExpression(new []
                            {
                                new Expression.Array(new ArrayExpression(
                                        new []
                                        {
                                            num[2],
                                            num[3]
                                        }, true
                                    )
                                )
                            }, true)
                        )
                        , new DataType.Array(new DataType.Array(new DataType.Int())))
                ),
                new[]
                {
                    num[1],
                    num[2]
                });
            Assert.Equal(expected, select.Projection.Single().AsExpr());


            sql = "SELECT ARRAY[]";
            select = VerifiedOnlySelect(sql);
            var arr = new Expression.Array(new ArrayExpression(new Sequence<Expression>(), true));
            Assert.Equal(arr, select.Projection.Single().AsExpr());
        }

        [Fact]
        public void Parse_Array_SubQuery_Expr()
        {
            var select = VerifiedOnlySelect("SELECT ARRAY(SELECT 1 UNION SELECT 2)");
            var body = new SetExpression.SetOperation(
                new SetExpression.SelectExpression(new Select(new[]
                {
                    new SelectItem.UnnamedExpression(new LiteralValue(Number("1")))
                })),
                SetOperator.Union,
                new SetExpression.SelectExpression(new Select(new[]
                {
                    new SelectItem.UnnamedExpression(new LiteralValue(Number("2")))
                })),
                SetQuantifier.None);
            var expected = new ArraySubquery(new Query(body));

            Assert.Equal(expected, select.Projection.Single().AsExpr());
        }

        [Fact]
        public void Test_Transaction_Statement()
        {
            var statement = VerifiedStatement<Statement.SetTransaction>("SET TRANSACTION SNAPSHOT '000003A1-1'");
            var expected = new Statement.SetTransaction(null, new Value.SingleQuotedString("000003A1-1"));
            Assert.Equal(expected, statement);

            statement = VerifiedStatement<Statement.SetTransaction>(
                "SET SESSION CHARACTERISTICS AS TRANSACTION READ ONLY, READ WRITE, ISOLATION LEVEL SERIALIZABLE");
            expected = new Statement.SetTransaction(new TransactionMode[]
            {
                new TransactionMode.AccessMode(TransactionAccessMode.ReadOnly),
                new TransactionMode.AccessMode(TransactionAccessMode.ReadWrite),
                new TransactionMode.IsolationLevel(TransactionIsolationLevel.Serializable)
            }, Session: true);
            Assert.Equal(expected, statement);
        }

        [Fact]
        public void Test_Savepoint()
        {
            var savepoint = VerifiedStatement<Statement.Savepoint>("SAVEPOINT test1");
            Assert.Equal(new Statement.Savepoint("test1"), savepoint);
        }

        [Fact]
        public void Test_Json()
        {
            DefaultDialects = new[] {new PostgreSqlDialect()};
            var select = VerifiedOnlySelect("SELECT params ->> 'name' FROM events");
            var expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("params"),
                JsonOperator.LongArrow,
                new LiteralValue(new Value.SingleQuotedString("name"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT params -> 'name' FROM events");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("params"),
                JsonOperator.Arrow,
                new LiteralValue(new Value.SingleQuotedString("name"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info -> 'items' ->> 'product' FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.Arrow,
                new JsonAccess(
                    new LiteralValue(new Value.SingleQuotedString("items")),
                    JsonOperator.LongArrow,
                    new LiteralValue(new Value.SingleQuotedString("product"))
                )
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info #> '{a,b,c}' FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.HashArrow,
                new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info #> '{a,b,c}' FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.HashArrow,
                new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info #>> '{a,b,c}' FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.HashLongArrow,
                new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info #>> '{a,b,c}' FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.HashLongArrow,
                new LiteralValue(new Value.SingleQuotedString("{a,b,c}"))
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @> '{\"a\": 1}'");
            var expr = new JsonAccess(
                new Identifier("info"),
                JsonOperator.AtArrow,
                new LiteralValue(new Value.SingleQuotedString("{\"a\": 1}"))
            );
            Assert.Equal(expr, select.Selection);


            select = VerifiedOnlySelect("SELECT info FROM orders WHERE '{\"a\": 1}' <@ info");
            expr = new JsonAccess(
                new LiteralValue(new Value.SingleQuotedString("{\"a\": 1}")),
                JsonOperator.ArrowAt,
                new Identifier("info")
            );
            Assert.Equal(expr, select.Selection);


            select = VerifiedOnlySelect("SELECT info #- ARRAY['a', 'b'] FROM orders");
            expected = new SelectItem.UnnamedExpression(new JsonAccess(
                new Identifier("info"),
                JsonOperator.HashMinus,
                new Expression.Array(new ArrayExpression(new []
                    {
                        new LiteralValue(new Value.SingleQuotedString("a")),
                        new LiteralValue(new Value.SingleQuotedString("b"))
                    }, true)
                )
            ));
            Assert.Equal(expected, select.Projection.Single());


            select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @? '$.a'");
            expr = new JsonAccess(
                new Identifier("info"),
                JsonOperator.AtQuestion,
                new LiteralValue(new Value.SingleQuotedString("$.a"))
            );
            Assert.Equal(expr, select.Selection);


            select = VerifiedOnlySelect("SELECT info FROM orders WHERE info @@ '$.a'");
            expr = new JsonAccess(
                new Identifier("info"),
                JsonOperator.AtAt,
                new LiteralValue(new Value.SingleQuotedString("$.a"))
            );
            Assert.Equal(expr, select.Selection);

        }

        [Fact]
        public void Test_Composite_Value()
        {
            var select = VerifiedOnlySelect("SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9");
            var expectedProjection = new SelectItem.UnnamedExpression(new CompositeAccess(new Nested(new CompoundIdentifier(
                new Ident[]
                {
                    "on_hand",
                    "item"
                })), "name"));

            var expectedSelection = new BinaryOp(
                new CompositeAccess(new Nested(new CompoundIdentifier(new Ident[]
                {
                    "on_hand",
                    "item"
                })), "price"),
               BinaryOperator.Gt,
                new LiteralValue(Number("9"))
            );

            Assert.Equal(expectedProjection, select.Projection.Single());
            Assert.Equal(expectedSelection, select.Selection);


            select = VerifiedOnlySelect("SELECT (information_schema._pg_expandarray(ARRAY['i', 'i'])).n");
            expectedProjection = new SelectItem.UnnamedExpression(
                new CompositeAccess(new Nested(new Function(
                    new ObjectName(new Ident[]
                    {
                        "information_schema",
                        "_pg_expandarray"
                    }))
                {
                    Args = new FunctionArg[]
                    {
                        new FunctionArg.Unnamed(new FunctionArgExpression.FunctionExpression(new Expression.Array(new ArrayExpression(new[]
                        {
                            new LiteralValue(new Value.SingleQuotedString("i")),
                            new LiteralValue(new Value.SingleQuotedString("i"))
                        }, true))))
                    }
                }), "n")
            );

            Assert.Equal(expectedProjection, select.Projection.Single());
        }

        [Fact]
        public void Parse_Comments()
        {
            var comment = VerifiedStatement<Statement.Comment>("COMMENT ON COLUMN tab.name IS 'comment'");
            var expected = new Statement.Comment(new ObjectName(new List<Ident> { "tab", "name" }), CommentObject.Column, "comment");
            Assert.Equal(expected, comment);


            comment = VerifiedStatement<Statement.Comment>("COMMENT ON TABLE public.tab IS 'comment'");
            expected = new Statement.Comment(new ObjectName(new List<Ident> { "public", "tab" }), CommentObject.Table, "comment");
            Assert.Equal(expected, comment);


            comment = VerifiedStatement<Statement.Comment>("COMMENT IF EXISTS ON TABLE public.tab IS NULL");
            expected = new Statement.Comment(new ObjectName(new List<Ident> { "public", "tab" }), CommentObject.Table, IfExists: true);
            Assert.Equal(expected, comment);
        }

        [Fact]
        public void Parse_Quoted_Identifier()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("""
                SELECT "quoted "" ident"
                """);
        }

        [Fact]
        public void Parse_Quoted_Identifier_2()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("SELECT \"\"\"quoted ident\"\"\"");
        }

        [Fact]
        public void Parse_Local_And_Global()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("CREATE LOCAL TEMPORARY TABLE table (COL INT)");
        }

        [Fact]
        public void Parse_On_Commit()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT PRESERVE ROWS");
            VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT DELETE ROWS");
            VerifiedStatement("CREATE TEMPORARY TABLE table (COL INT) ON COMMIT DROP");
        }

        [Fact]
        public void Parse_Escaped_Literal_String()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var select = VerifiedOnlySelect("""
                SELECT E's1 \n s1', E's2 \\n s2', E's3 \\\n s3', E's4 \\\\n s4', E'\'', E'foo \\'
                """);

            Assert.Equal(6, select.Projection.Count);
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("s1 \n s1")), select.Projection[0].AsExpr());
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("s2 \\n s2")), select.Projection[1].AsExpr());
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("s3 \\\n s3")), select.Projection[2].AsExpr());
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("s4 \\\\n s4")), select.Projection[3].AsExpr());
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("'")), select.Projection[4].AsExpr());
            Assert.Equal(new LiteralValue(new Value.EscapedStringLiteral("foo \\")), select.Projection[5].AsExpr());

            var ex = Assert.Throws<TokenizeException>(() => ParseSqlStatements("SELECT E'\\'"));
            Assert.Equal("Unterminated encoded string literal after Line: 1, Col: 8", ex.Message);
        }

        [Fact]
        public void Parse_Declare()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" CURSOR WITH HOLD FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" CURSOR WITHOUT HOLD FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" BINARY CURSOR FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" ASENSITIVE CURSOR FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" INSENSITIVE CURSOR FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" SCROLL CURSOR FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" NO SCROLL CURSOR FOR SELECT 1");
            VerifiedStatement("DECLARE \"SQL_CUR0x7fa44801bc00\" BINARY INSENSITIVE SCROLL CURSOR WITH HOLD FOR SELECT * FROM table_name LIMIT 2222");
        }

        [Fact]
        public void Parse_Current_Functions()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var select = VerifiedOnlySelect("SELECT CURRENT_CATALOG, CURRENT_USER, SESSION_USER, USER");
            Assert.Equal(new Function("CURRENT_CATALOG") { Special = true }, select.Projection[0].AsExpr());
            Assert.Equal(new Function("CURRENT_USER") { Special = true }, select.Projection[1].AsExpr());
            Assert.Equal(new Function("SESSION_USER") { Special = true }, select.Projection[2].AsExpr());
            Assert.Equal(new Function("USER") { Special = true }, select.Projection[3].AsExpr());
        }

        [Fact]
        public void Parse_Fetch()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            VerifiedStatement("FETCH 2048 IN \"SQL_CUR0x7fa44801bc00\"");
            VerifiedStatement("FETCH 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH NEXT IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH PRIOR IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH FIRST IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH LAST IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH ABSOLUTE 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH RELATIVE 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH FORWARD 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH FORWARD ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH BACKWARD 2048 IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
            VerifiedStatement("FETCH BACKWARD ALL IN \"SQL_CUR0x7fa44801bc00\" INTO \"new_table\"");
        }

        [Fact]
        public void Parse_Custom_Operator()
        {
            var select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(database.pg_catalog.~) '^(table)$'");
            var expected = new BinaryOp(
                new Identifier("relname"),
                BinaryOperator.PGCustomBinaryOperator,
                new LiteralValue(new Value.SingleQuotedString("^(table)$"))
            )
            {
                PgOptions = new[]
                {
                    "database",
                    "pg_catalog",
                    "~"
                }
            };
            Assert.Equal(expected, select.Selection);


            select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(pg_catalog.~) '^(table)$'");
            expected = new BinaryOp(
                new Identifier("relname"),
                BinaryOperator.PGCustomBinaryOperator,
                new LiteralValue(new Value.SingleQuotedString("^(table)$"))
            )
            {
                PgOptions = new[]
                {
                    "pg_catalog",
                    "~"
                }
            };
            Assert.Equal(expected, select.Selection);


            select = VerifiedOnlySelect("SELECT * FROM events WHERE relname OPERATOR(~) '^(table)$'");
            expected = new BinaryOp(
                new Identifier("relname"),
                BinaryOperator.PGCustomBinaryOperator,
                new LiteralValue(new Value.SingleQuotedString("^(table)$"))
            )
            {
                PgOptions = new[]
                {
                    "~"
                }
            };
            Assert.Equal(expected, select.Selection);
        }

        [Fact]
        public void Parse_Create_Role()
        {
            var role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE IF NOT EXISTS mysql_a, mysql_b");
            var expected = new Statement.CreateRole(new ObjectName[]
            {
                "mysql_a",
                "mysql_b"
            })
            {
                IfNotExists = true
            };
            Assert.Equal(expected, role);


            role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc LOGIN PASSWORD NULL");
            Assert.Equal(new ObjectName[] { "abc" }, role.Names);
            Assert.Equal(new Password.NullPassword(), role.Password);
            Assert.True(role.Login);

            //role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc WITH LOGIN PASSWORD NULL");
            role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE abc WITH LOGIN PASSWORD NULL").First()!;
            Assert.Equal(new ObjectName[] { "abc" }, role.Names);
            Assert.Equal(new Password.NullPassword(), role.Password);
            Assert.True(role.Login);


            //role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE magician WITH SUPERUSER CREATEROLE NOCREATEDB BYPASSRLS INHERIT PASSWORD 'abcdef' LOGIN VALID UNTIL '2025-01-01' IN ROLE role1, role2 ROLE role3 ADMIN role4, role5 REPLICATION");
            role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE magician WITH SUPERUSER CREATEROLE NOCREATEDB BYPASSRLS INHERIT PASSWORD 'abcdef' LOGIN VALID UNTIL '2025-01-01' IN ROLE role1, role2 ROLE role3 ADMIN role4, role5 REPLICATION").First()!;

            Assert.Equal(new ObjectName[] { "magician" }, role.Names);
            Assert.False(role.IfNotExists);
            Assert.True(role.Login);
            Assert.True(role.Inherit);
            Assert.True(role.BypassRls);
            Assert.Equal(new Password.ValidPassword(new LiteralValue(new Value.SingleQuotedString("abcdef"))), role.Password);
            Assert.True(role.Superuser);
            Assert.False(role.CreateDb);
            Assert.True(role.CreateDbRole);
            Assert.True(role.Replication);
            Assert.Equal(new LiteralValue(new Value.SingleQuotedString("2025-01-01")), role.ValidUntil);
            Assert.Equal(new Ident[] { "role1", "role2" }, role.InRole!);
            Assert.Equal(new Ident[] { "role3" }, role.Role!);
            Assert.Equal(new Ident[] { "role4", "role5" }, role.Admin!);
            Assert.Null(role.AuthorizationOwner);
            Assert.Null(role.User);
            Assert.Null(role.InGroup);

            //role = VerifiedStatement<Statement.CreateRole>("CREATE ROLE abc WITH USER foo, bar ROLE baz ");
            role = (Statement.CreateRole)ParseSqlStatements("CREATE ROLE abc WITH USER foo, bar ROLE baz ").First()!;
            Assert.Equal(new ObjectName[] { "abc" }, role.Names);
            Assert.Equal(new Ident[]{ "foo", "bar" }, role.User!);
            Assert.Equal(new Ident[]{ "baz" }, role.Role!);

            foreach (var keyword in new[]
                     {
                         "BYPASSRLS",
                         "CREATEDB",
                         "CREATEROLE",
                         "INHERIT",
                         "LOGIN",
                         "REPLICATION",
                         "SUPERUSER"
                     })
            {
                var sql = $"CREATE ROLE abc {keyword} NO{keyword}";
                var ex = Assert.Throws<ParserException>(() => ParseSqlStatements(sql));
                Assert.Equal($"Found multiple {keyword} or NO{keyword}", ex.Message);
            }
        }

        [Fact]
        public void Parse_Delimited_Identifiers()
        {
            var select = VerifiedOnlySelect("SELECT \"alias\".\"bar baz\", \"myfun\"(), \"simple id\" AS \"column alias\" FROM \"a table\" AS \"alias\"");

            var table = new TableFactor.Table(new ObjectName(new Ident("a table", Symbols.DoubleQuote)))
            {
                Alias = new TableAlias(new Ident("alias", Symbols.DoubleQuote))
            };

            Assert.Equal(table, select.From!.Single().Relation);
            Assert.Equal(3, select.Projection.Count);
            Assert.Equal(new CompoundIdentifier(new Ident[]
            {
                new ("alias", Symbols.DoubleQuote),
                new ("bar baz", Symbols.DoubleQuote)
            }), select.Projection[0].AsExpr());
            Assert.Equal(new Function(new ObjectName(new Ident("myfun", Symbols.DoubleQuote))), select.Projection[1].AsExpr());

            Assert.Equal(new SelectItem.ExpressionWithAlias(new Identifier(
                new Ident("simple id", Symbols.DoubleQuote)),
                new Ident("column alias", Symbols.DoubleQuote)),
                select.Projection[2]);

            VerifiedStatement("CREATE TABLE \"foo\" (\"bar\" \"int\")");
            VerifiedStatement("ALTER TABLE foo ADD CONSTRAINT \"bar\" PRIMARY KEY (baz)");
        }

        [Fact]
        public void Parse_Like()
        {
            Test(false);
            Test(true);

            void Test(bool negated)
            {
                var negation = negated ? "NOT " : null;

                var select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}LIKE '%a'");
                var expected = new Like(new Identifier("name"), negated,
                    new LiteralValue(new Value.SingleQuotedString("%a")));
                Assert.Equal(expected, select.Selection);

                select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}LIKE '%a' ESCAPE '\\'");
                expected = new Like(new Identifier("name"), negated,
                    new LiteralValue(new Value.SingleQuotedString("%a")), Symbols.Backslash);
                Assert.Equal(expected, select.Selection);

                // This statement tests that LIKE and NOT LIKE have the same precedence.
                select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}LIKE '%a' IS NULL");
                var isNull = new IsNull(new Like(new Identifier("name"), negated,
                    new LiteralValue(new Value.SingleQuotedString("%a"))));
                Assert.Equal(isNull, select.Selection);
            }
        }

        [Fact]
        public void Parse_Similar_To()
        {
            Test(false);
            Test(true);

            void Test(bool negated)
            {
                var negation = negated ? "NOT " : null;

                var select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}SIMILAR TO '%a'");
                var expected = new SimilarTo(new Identifier("name"), negated, new LiteralValue(new Value.SingleQuotedString("%a")));
                Assert.Equal(expected, select.Selection);

                select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}SIMILAR TO '%a' ESCAPE '\\'");
                expected = new SimilarTo(new Identifier("name"), negated, new LiteralValue(new Value.SingleQuotedString("%a")), Symbols.Backslash);
                Assert.Equal(expected, select.Selection);

                // This statement tests that LIKE and NOT LIKE have the same precedence.
                select = VerifiedOnlySelect($"SELECT * FROM customers WHERE name {negation}SIMILAR TO '%a' ESCAPE '\\' IS NULL");
                var isNull = new IsNull(new SimilarTo(new Identifier("name"), negated, new LiteralValue(new Value.SingleQuotedString("%a")), Symbols.Backslash));
                Assert.Equal(isNull, select.Selection);
            }
        }

        [Fact]
        public void Parse_Create_Function()
        {
            var create = VerifiedStatement<Statement.CreateFunction>("CREATE FUNCTION add(INTEGER, INTEGER) RETURNS INTEGER LANGUAGE SQL IMMUTABLE AS 'select $1 + $2;'");
            var expected = new Statement.CreateFunction("add", new CreateFunctionBody
            {
                Language = "SQL",
                Behavior = FunctionBehavior.Immutable,
                As = new FunctionDefinition.SingleQuotedDef("select $1 + $2;")
            })
            {
                Args = new OperateFunctionArg[]
                {
                    new (ArgMode.None) { DataType = new DataType.Integer() },
                    new (ArgMode.None) { DataType = new DataType.Integer() }
                },
                ReturnType = new DataType.Integer()
            };
            Assert.Equal(expected, create);


            create = VerifiedStatement<Statement.CreateFunction>("CREATE OR REPLACE FUNCTION add(a INTEGER, IN b INTEGER = 1) RETURNS INTEGER LANGUAGE SQL IMMUTABLE RETURN a + b");
            expected = new Statement.CreateFunction("add", new CreateFunctionBody
            {
                Language = "SQL",
                Behavior = FunctionBehavior.Immutable,
                Return = new BinaryOp(
                    new Identifier("a"),
                   BinaryOperator.Plus,
                    new Identifier("b")
                )
            })
            {
                Args = new OperateFunctionArg[]
                {
                    new (ArgMode.None) { DataType = new DataType.Integer(), Name = "a"},
                    new (ArgMode.In) { DataType = new DataType.Integer(), Name = "b", DefaultExpr = new LiteralValue(Number("1"))}
                },
                ReturnType = new DataType.Integer(),
                OrReplace = true
            };
            Assert.Equal(expected, create);

            create = VerifiedStatement<Statement.CreateFunction>("CREATE OR REPLACE FUNCTION increment(i INTEGER) RETURNS INTEGER LANGUAGE plpgsql AS $$ BEGIN RETURN i + 1; END; $$");
            expected = new Statement.CreateFunction("increment", new CreateFunctionBody
            {
                Language = "plpgsql",
                As = new FunctionDefinition.DoubleDollarDef(" BEGIN RETURN i + 1; END; ")
            })
            {
                OrReplace = true,
                Args = new OperateFunctionArg[] { new(ArgMode.None) { Name = "i", DataType = new DataType.Integer() } },
                ReturnType = new DataType.Integer()
            };
            Assert.Equal(expected, create);
        }

        [Fact]
        public void Parse_Drop_Function()
        {
            var drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func");
            var expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
                {
                    new("test_func")
                },
                ReferentialAction.None);
            Assert.Equal(expected, drop);


            drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func(a INTEGER, IN b INTEGER = 1)");
            expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
                {
                    new("test_func")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Integer()},
                            new(ArgMode.In)
                            {
                                Name = "b", DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    }
                },
                ReferentialAction.None);
            Assert.Equal(expected, drop);


            drop = VerifiedStatement<Statement.DropFunction>("DROP FUNCTION IF EXISTS test_func1(a INTEGER, IN b INTEGER = 1), test_func2(a VARCHAR, IN b INTEGER = 1)");
            expected = new Statement.DropFunction(true, new Statement.DropFunctionDesc[]
                {
                    new("test_func1")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Integer()},
                            new(ArgMode.In)
                            {
                                Name = "b",
                                DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    },
                    new("test_func2")
                    {
                        Args = new OperateFunctionArg[]
                        {
                            new(ArgMode.None){ Name = "a", DataType = new DataType.Varchar()},
                            new(ArgMode.In)
                            {
                                Name = "b",
                                DataType = new DataType.Integer(),
                                DefaultExpr = new LiteralValue(Number("1"))
                            }
                        }
                    }
                },
                ReferentialAction.None);
            Assert.Equal(expected, drop);
        }

        [Fact]
        public void Parse_Dollar_Quoted_string()
        {
            var statements = ParseSqlStatements("SELECT $$hello$$, $tag_name$world$tag_name$, $$Foo$Bar$$, $$Foo$Bar$$col_name, $$$$, $tag_name$$tag_name$");

            var query = (Statement.Select)statements[0]!;
            var select = (SetExpression.SelectExpression)query.Query.Body;
            var projection = select.Select.Projection;

            Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("hello"))), projection[0].AsExpr());
            Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("world", "tag_name"))), projection[1].AsExpr());
            Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("Foo$Bar"))), projection[2].AsExpr());
            var expr = new SelectItem.ExpressionWithAlias(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("Foo$Bar"))), "col_name");
            Assert.Equal(expr, projection[3]);
            Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue(""))), projection[4].AsExpr());
            Assert.Equal(new LiteralValue(new Value.DollarQuotedString(new DollarQuotedStringValue("", "tag_name"))), projection[5].AsExpr());
        }

        [Fact]
        public void Parse_Incorrect_Dollar_Quoted_String()
        {
            Assert.Throws<TokenizeException>(() => ParseSqlStatements("SELECT $x$hello$$"));
            Assert.Throws<TokenizeException>(() => ParseSqlStatements("SELECT $hello$$"));
            Assert.Throws<TokenizeException>(() => ParseSqlStatements("\"SELECT $$$"));
        }

        [Fact]
        public void Parse_Truncate()
        {
            DefaultDialects = new Dialect[] { new PostgreSqlDialect(), new GenericDialect() };

            var truncate = VerifiedStatement("TRUNCATE db.table_name");

            var name = new ObjectName(new Ident[] {"db", "table_name"});
            var expected = new Statement.Truncate(name, null, false);
            Assert.Equal(expected, truncate);
        }
    }
}
